---
title: 性能优化
date: 2024/07/20
tags:
 - 网络
categories:
 - 网络
---

![性能指标](./assets/peformance/peformance.png "性能指标")

## performance.timing对象属性属性含义

### navigationStart

当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。

### unloadEventStart

前一页面卸载开始，如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。

### unloadEventEnd

前一页面卸载结束，如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。

### redirectStart

重定向开始，返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。

### redirectEnd

重定向结束，返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。

### fetchStart

页面开始加载，返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。

### domainLookupStart

DNS查询开始，返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。

### domainLookupEnd

DNS查询结束，返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。

### connectStart

SSL连接开始，返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。

### secureConnectionStart

返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。

### connectEnd

SSL连接结束，返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。

### requestStart

开始请求页面文档，返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。

### responseStart

首字节时间，返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。

### responseEnd

结束请求页面文档，返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。

### domLoading

DOM 开始加载，返回当前网页DOM结构开始解析时（即Document.readyState属性变为loading、相应的readystatechange事件触发时）的Unix毫秒时间戳。

### domInteractive

DOM 解析结束，返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为interactive、相应的readystatechange事件触发时）的Unix毫秒时间戳。

### domContentLoadedEventStart

开始加载远程资源，返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。

### domContentLoadedEventEnd

DOM Ready时间，返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。

### domComplete

资源全部准备就绪（含异步），返回当前网页DOM结构生成时（即Document.readyState属性变为complete，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。

### loadEventStart

页面完全加载时间，返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。

### loadEventEnd

onload回调函数结束，返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。

## 浏览器渲染过程

1. 加载HTML文档：浏览器从磁盘或网络读取HTML原始字节
2. 解析HTML文档：解析HTML内容，加载`<head>`和`<body>`中的静态文件
3. 构建DOM和CSSOM，合并渲染树。将HTML转换成令牌，形成树模型
4. 布局和绘制。渲染树生成“盒模型”，获得视口内的确切位置和大小，将渲染树节点绘制为屏幕上的实际像素
5. 完全加载，开始异步加载资源，同时也会下载字体、图片等远程文件

经过以上5个阶段，就完成了网页的加载和渲染，有效的利用Web性能指标的关键就在于抓住1-5阶段的关键时间点，以此来找到相对应的性能优化策略。

## 网页加载的核心指标

![浏览器渲染流程](./assets/peformance/step.png '浏览器渲染流程')

### 首字节时间-responseStartTime

指浏览器接收到HTML文档第一个字节的时间。此时间点之前，浏览器需要经过DNS解析、重定向(若有)、建立TCP/SSL连接、服务器响应等过程。
反映的问题：服务器、CDN性能
对应测速点：responseStart
问题分析：该阶段耗时过长代表着服务器响应和返回的时间长
排查方向：DNS查询时间长、重定向过多、TCP连接时间长、服务器性能差

### DOM构建完成时间/可交互时间-domInteractiveTime

HTML解析器完成DOM树构建的时间。此时间点之前，浏览器需要经过同步静态资源加载、内联JavaScript脚本运行、HTML解析器生成 DOM树的过程。此时网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作。
反映问题：前端代码执行性能，加载策略
对应测速点：domInteractive
问题分析：浏览器解析HTML构建DOM树的过程中，会遇到JS、CSS等关键资源，而JS资源默认会阻塞DOM树的构建，直接影响了该阶段的性能
排查方向：
未对非关键的JS脚本使用异步标记，或是在空闲时异步加载非关键脚本
未对代码进行合理拆分，导致单个js脚本过大
未优先加载当前页面所需的关键js资源
未合理配置缓存策略

### DOM Ready时间

CSS树和DOM树合并渲染树后，并执行完成同步JavaScript脚本的时间。此时间点之前，包含了DOM树构建的过程、CSS树构建的过程、以及同步JavaScript脚本执行的时间。
反映问题：css资源阻塞
对应测速点：domContentLoadedEventEnd
问题分析：该阶段内要完成DOM和CSSOM的构建，因此还需要考虑CSS资源的阻塞因素
排查方向：未今早引入关键CSS资源
未对CSS内容合理拆分，导致关键内容和非关键内容混合在一起
未合理配置缓存策略
未合理是用CSS import指令
未对非关键的CSS资源使用媒体查询等方式消除阻塞

### 首屏时间

首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。但是基于加载指标类的数据采集，不足以验证页面的真实性能，结合感官可使用的首屏的时间，来作为首屏时间。
详细内容可见首屏时间定义及计算方式。
问题分析：首屏时间由首屏内容加载完成的时间决定
排查方向：未使用资源提示尽早下载首屏内容相关的资源
未优先发送首屏内容相关的请求
未对首屏外对内容使用异步加载和懒加载

### 完全加载时间

DOM Tree构建完成后，开始加载网页资源，资源完全加载完成的时间。此时会触发浏览器onload事件。
反映的问题：资源加载问题、前端代码性能
计算方式：loadEventStart
问题分析：该阶段内要完成页面上所有资源的加载，资源加载的方式和资源的数据量都会影响该阶段的性能
排查方向：未对资源进行合理压缩
未合理配置缓存策略
未对图片等资源进行合理优化

## 优化思路

分析思路，慢的原因是什么？

- 服务器响应慢
- 阻断渲染的js/css
- 资源加载时间长
- 客户端渲染机器影响

优化方案

- 服务器优化：缓存html页面、页面资源，减少浏览器直接请求资源 => 缓存机制（面试）
- 图片优化：采用不同图片格式等，减少图片体积，提高图片加载速度
- 代码优化：重构、压缩、注释过滤
- 使用cdn
- 渲染阻断优化：

## 性能分析工具

1、前端监控：owl、raptor等
2、常见工具：Chrome Performance、Light house


文档加载过程
文档渲染呈现过程
交互过
文档加载过程： 
DCL：空白到出现内容所花费的时间 
渲染呈现过程：
FP&FCP：首次绘制（FP，可能是背景色或loading），首次内容绘制时间（FCP）
FMP：首要内容出现在屏幕上的时间
LCP：视窗内最大的元素绘制的时
交互过程：
TTI：网页首次完全达到可交互状态的时间点
FPS：每秒可以重新绘制的帧数，用于衡量应用流畅度

## 每个因素优化措施

### 网络加载

1.减少DNS查找
具体措施：主机名一般不要超过4个，并且在页面上增加meta标签prefetch预热dns，服务端开启keep-alive

2.避免重定向
具体措施：避免重定向的代码

3.使用CDN，地域更近的响应会更快
具体措施：根据访问用户的分布，在多个地域部署CDN节点

4.减少http请求
具体措施：合并图片（sprite image，iconfont，svg），合并资源文件（css，js）

5.压缩资源文件，减小资源文件体积，减少网络流量的消耗
具体措施：minify压缩html, js, css等

6.开启服务端文件压缩算法
具体措施：开启gzip

7.移除重复脚本
具体措施：代码编写时检查，代码构建时检查

8.样式表放顶部
具体措施：css加载代码放在head中，防止js加载阻塞呈现白屏

9.脚本放底部
具体措施：js加载代码放在body底部，防止脚本阻塞呈现白屏

10.使用外部的js和css
具体措施：首页cookie判断资源文件是否已缓存，如无则服务端加载内联页面，同时去下载那些资源文件。如有，则服务端加载外部组件页面

11.首屏数据请求提前，避免大JavaScript文件加载后才请求数据
具体措施：可以将页面核心请求库的js，以及首屏数据的请求代码位置提前

12.首屏内容最小化，首屏加载和按需加载，非首屏内容滚屏加载
具体措施：code split，lazy load

13.资源并行下载
具体措施：没有加载依赖顺序的资源可以使用不同的域名地址，例如：css与js资源文件访问的域名可以不同

14.inline首屏css和js
具体措施：构建时增加处理

15.MTU策略
具体措施：html页面尽量保证在1KB（gzip）以内

### 界面渲染

1.meta viewport控制
具体措施：设置device-width，不缩放比率（缩放比率会降低渲染性能）

2.最小化各种形式重排重绘
具体措施：合并操作css样式 cssText, className， 控制获取布局信息（会导致重排->重绘）api 的使用（offsetTop, scrollHeight, clientWidth, getComputedStyle, getBoundingClientRect...）

3.使用css3动画，开启GPU加速
具体措施：transform: translate3D设置z轴

4.在频繁增删dom的情况下，使用canvas

5.使用requestAnimationFrame代替setTimeout

6.使用sprite image，iconfont，svg来代替icon图片

7.使用文档片段，将要操作的dom脱离文档流，并加入文档片段操作，之后再放回文档流

8.事件委托

9.让元素脱离动画流，绝对定位

### 缓存

1.（浏览器缓存）服务器设置响应缓存规则
具体措施：响应头expire，max-age, cache-control设置永不过期，根据请求的资源的hash值来更新缓存

2.（浏览器缓存）缓存ajax get请求响应内容
具体措施：代码中根据情况，针对实际情况，可缓存响应内容至内存中，缓存过期时间可以是几秒，几分钟，甚至更多的时间

3.离线资源
具体措施：使用localStorage，本地 db，serviceWorker，native拉取离线包（针对移动 app hybrid ）

### 图片

1.图片压缩处理
具体措施：无损压缩到极限，尽量采用 jpg 格式（文件更小）

2.尽量减少不必要的图片，合理使用base64内嵌图片，一般不要超过2K
具体措施：使用sprite image，iconfont，svg,  base64通过构建时控制超过 2k 时使用外链图片

3.使用webp
具体措施：使用webp格式的图片（文件更小）

4.图片懒加载
具体措施：lazy load

5.根据不同屏幕加载不同大小图片
具体措施：使用 Media Query，或者 js 获取屏幕倍率来控制

6.定义图片小大限制
具体措施：比如，不允许超过 300 k 的图片

### CSS执行优化

1.不使用css表达式
2.避免使用通配符*
3.不使用限定ID，比如div#id -> #id
4.不使用限定类，比如li.item -> .li-item
5.让规则越具体越好，选择器层次越浅越好
6.减少使用后代选择器
7.减少使用子选择器（比较难）
8.多依靠继承

### JS执行优化

1.减少调用栈使用次数
具体措施：比如webpack module concetrate，可以检测合并模块代码，减少function数量

2.部署更高版本的代码
具体措施：比如在移动h5项目中直接部署es2015代码，可以提升js代码的解释、执行的速度

3.架构与协议
使用SPDY和HTTP2
具体措施：需要服务器与浏览器支持

4.服务端渲染
具体措施：针对前后端完全分离项目，做构建时 ssr，实时 ssr，以及同构

5.NativeView代替DOM的性能劣势
具体措施：针对移动 ative，react-native/weex