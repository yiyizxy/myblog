---
title: 垃圾回收
date: 2024/07/28
tags:
 - javascript
categories:
 - javascript
---

## 内存溢出 vs 内存泄漏 

### 内存溢出（out of memory OOM）

一种程序运行出现的错误。当程序运行时需要的内存超过剩余的内存时，就会内存溢出的错误。

```js
// 由于循环量过大导致物理内存不够
const obj = {}
for (var i = 0; i < 100000000; i++) {
   obj[i] = new Array(100000000)
   console.log('-----------------')
}
```

### 内存泄漏（memory leak）

- 占用的内存没有及时释放。
- 内存泄露积累多了就容易导致内存溢出。

### 常见内存泄漏

- 全局变量意外赋值
- 闭包导致变量无法释放
- 没有及时清理的定时器
- 事件监听没有及时清除
- 数据结构（如数组、Map、Set）持续增长
- 其他

```js
// 全局变量意外赋值
function fn1() {
  a = 1
  console.log(a)
}
fn1()

// 闭包导致变量无法释放
function fn1() {
    let a = 2
    function fn2() {
        console.log(++a)
    }
    return fn2
}
const fn = fn1()
fn()
// 执行完函数之后a没有被释放掉，是因为fn保存了fn1函数。
// fn = null // 释放内存

// 没有及时清理的定时器或回调函数
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);

// 其他
// console.log(data)
// 事件监听
// 循环引用
```

## 垃圾回收常见算法

### 标记清除法

整个标记清除算法大致过程就像下面这样:

1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
2. 然后从各个根对象开始遍历，把不是垃圾的节点改成1
3. 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
4. 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

优点
标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单

缺点
内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢

![标记清除法](./assets/garbage/mark.png '标记清除法')

### 引用计数算法

1. 它的策略是跟踪记录每个变量值被使用的次数，当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为1，
2. 如果同一个值又被赋给另一个变量，那么引用数加 1
3. 如果该变量的值被其他的值覆盖了，则引用次数减 1
4. 当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为0的值占用的内存

优点
只要引用次数为0时，就会被立即回收

缺点
需要维护一个计数器，占用很大的位置，而且不知道被引用次数的上限，导致遇到循环引用的情况下无法回收

## V8垃圾回收机制

- V8垃圾回收策略主要基于分代式垃圾回收机制，将堆中内存分为新生代区和老生代区，采用不同的垃圾回收机制。
- 新生代的对象主要为存活时间较短的对象，即新产生的对象，通常只有1-8M容量，老生代主要存放存活时间较长或者常驻内存的对象，即经历过新生代垃圾回收还存活下来的对象，容量通常比较大。
- 新生代垃圾回收使用Scavenge算法，将堆内存一分为二，分别为使用区和空间区，新加入的对象会把被放入使用区，如果使用区内存满后会执行垃圾回收，首先，新生代垃圾回收器会对使用区的中的活动对象标记，标记完成后会将使用区的活动对象复制到空闲区，随后进入垃圾回收，即将非活动对象占用的空间清理掉，最后进行角色替换，将原使用区变成空闲区，将空闲区转变为使用区。
- 当一个对象经过多次复制后依然存活，则被认为是生命周期较长的对象，会被晋升到老生代区，另外，如果某个对象复制到空闲区时，占使用区25%的内存以上也会直接晋升到老生代区
- 老生代垃圾回收则采用标记清除法，首先是标记阶段，对老生代第一次遍历，标记存活对象；然后对老生代第二次遍历，清除非活动对象；接着采用标记整理法将存活对象往内存的一端移动，最后清理存活对象外的内存。

新生代垃圾回收使用Scavenge算法缺点是啥？只能使用堆内存的一半，但是由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上比较优秀。

[你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)