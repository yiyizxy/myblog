---
title: Introduce
date: 2024/07/01
tags:
 - javascript
categories:
 - javascript
---
## 个人

### 你的优势是什么？

### 说说你做过的最好的一个项目？

### 你为什么要换工作？

- 在大学毕业已校招生的身份进入美团到现在连续工作了6年多的时间，发现现阶段的工作成长空间有限
- 想换个环境
- 22年生了宝宝，马上要上学了，希望有更多的时间可以陪伴娃，投入到娃的教育上
- 希望自己有更多的时间做一些自己感兴趣的事情，能够一周保持3-4次运动，例如普拉提、瑜伽、游泳，也希望自己有更多的时间可以去探索其他领域的一些技能，例如历史、探索世界、心理学、保险、金融、投资理财
- 自我提升以及

## 城市运营

- 页面布局搭建
  1. SPA
  2. MPA
- 数据管理: redux调研，使用的是redux-tooltik
- 登录 && 权限
  1. 各个菜单如何做到权限管理
- 微前端、大文件上传、音频、水印

### 搭建

### 写评价扫码活动sh装饰器@

饰器工厂就是使用一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。需要`tsconfig.json`中配置

```js
function color(value: string) { // 这是一个装饰器工厂
    return function (target) { //  这是装饰器
        // do something with "target" and "value"...
    }
}
```

```json
  "compilerOptions": {
    "experimentalDecorators": true
  }
```

### 微前端

## 唤起

***唤端方式可持续性优化，组件扩展性强，迭代成本低、测试成本低；**

改造节奏： 唤起配置化 -> 唤起链路治理 -> 唤起组件重构

### open-app-manager

#### 背景

1. 接手免费流量运营组的SEO增长组业务时，现状是相关需求一直不断，产品尝试的手段逐渐变多，扩展的终端逐渐变多，入侵的业务逐渐变多。
2. 技术侧：存在以下痛点：1.无法快速高效地响应（20年调整28次，占所有唤起需求将近72%）产品唤起策略修改类需求：部分修改都要手动代码修改，人力成本较高， 2.唤起代码和业务代码耦合度高：增长类需求代码入侵业务代码过多，代码耦合度高随处可见的唤起类代码分散在业务代码的各个地方，存在影响业务基本功能的风险
3. 产品侧：产品规划上需要将站内业务搬到站外去引流，站内业务众多，我们不可能去熟悉各类业务，支持唤起，技术侧期望的合作方式是我们提供组件，业务方接入。

#### 目标

1. 降低唤起需求所需要的人力成本
2. 能快速灵活响应唤起策略调整需求
3. 降低唤起业务与业务本身的耦合程度
4. 可靠、稳定【唤起需求的调整，修改不影响业务页面的基本功能】

#### 谁在使用

适合页面存在大量唤起模块、需要针对安全方面风险、唤起效果验证、需要频繁调整唤起策略、需要将唤起逻辑与业务代码解耦的业务

#### 横向调研

| 应用     | 唤起量 | 唤起实现                                    | 是否使用了配置化 |
|----------|--------|---------------------------------------------|------------------|
| 美团i站  | 少     | 基本的唤起 没有不同渠道唤起不同的业务场景   | 否               |
| 美团外卖 | 无     | 没有唤起 没有不同渠道唤起不同的业务场景     | 否               |
| 小红书   | 中     | 基本的唤起 不同渠道的唤起不同使用硬编码实现 | 否               |
| 今日头条 | 中     | 基本的唤起 没有不同渠道唤起不同的业务场景   | 否               |
| 知乎     | 中     | 基本的唤起 没有不同渠道唤起不同的业务场景   | 否               |

注：

1. 如何看有没有做配置化？看有没有拉取配置的http请求
2. 如何看有没有不同渠道的不同唤起表现？看js代码
3. 如何看有没有使用声明式管理？data声明有没有？

#### 为什么点评站外存在唤起多样化的诉求？

可以从三个维度上解释：

1. 渠道维度：站外产品存在大量投放渠道，不同渠道下，存在对唤起的不同要求
例如：SEO渠道下不允许下载，产品通常使用唤起+下一步的策略，另外还有一些渠道下要求不唤起
2. 产品维度：产品有针对特定渠道进行定制唤起策略的诉求
不同时间下，唤起策略可能不同，例如强度和密度的调整，即存在从产品层面调整唤起策略，实现预期的指标增长的诉求，例如：调整防疲劳策略，调整唤起策略等
3. 环境维度：不同终端环境下，唤起能力存在差异，有根据不同环境定制唤起表现的诉求。
例如在微信中打开时，唤起策略会有所不同，又如iOS下，唤起策略与安卓不同。

#### 实现思路

1. 唤起配置化存在两个运营位，一是唤起参数配置：渠道来源(mSource)、页面标识()、唤起模块(launchKey)、唤起地址、唤起策略、自定义唤起策略、是否支持口令等，二是自定义唤起策略
2. 先获取配置平台的唤起配置相关参数，为了防止网络异常，接口有做重试优化
3. 根据配置的唤起模块使用```document.querySelectorAll(`[data-launch-name=${launchPoint.launchKey}]`)```收集页面上的唤起点，这里需要区分是否列表型节点，如是继续遍历children，否则判断节点是否初始化过inited，否则批量初始化唤起实例，点击时执行对应的唤起策略（唤起、唤起+下载、唤起+下载+下一页、自定义唤起策略：微信环境30分钟3次唤起+下载、微信环境不唤起等），这里面需要考虑自定义唤起策略，需要执行配置化平台上的唤起代码
4. 最后标志该唤起模块已经初始化过

#### 挑战

1. 列表型唤起点如何解决？首先需要接入方在dom节点上表明这是个列表型唤起节点
2. 动态节点如何解决绑定问题?使用js的MutationObserver的API观测DOM节点动态变化,防抖操作
3. 唤起地址存在动态参数如何处理？接入方在参数放在dom节点上，data-launch-data
4. 遇到唤起参数是动态获取的，但是唤起组件会在一开始的时候初始化，怎么解决？需要业务方待参数就绪后再设置唤起属性

#### 结果

1. 能够灵活快速调整唤起策略
2. 人力提效（2 - 0.58）/2 = 71%
3. 唤起代码与业务代码解偶，代码可维护性强

#### 代码片段

```js
handleDynamicDOM() {
    // TODO MutationObserver 能力检测 不支持的polyfill
    const observer = new MutationObserver(debounce(mutationsList => {
        if (mutationsList?.length) {
            this.config() // 绑定唤起实例
            if (this.isRequestError) {
                handleGetDataError()
            }
        }
    }, 500))
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}

// 自定义唤起策略执行
customOpenApp(antiFatigueKey, launchPoint, instance, e) {
  const { strategyFunction, strategyConstant } = launchPoint.customOpenAppStrategy
  let dynamicStrategy = new Function('strategyConstant', 'antiFatigueKey', 'logger', strategyFunction)
  try {
    let openAppStrategy = dynamicStrategy(strategyConstant, antiFatigueKey, this.logger)
    if (openAppStrategy && openAppStrategy !== 'noOpen') {
      this.mylog.customOpenApp() // 1201
      if (e) {
      const goToOpen = () => this.goToOpen({ strategy: openAppStrategy }, instance)
      setTimeout0(this.getShowPopupState(launchPoint) ? createOpenAppPopup : goToOpen)
      if (this.getShowPopupState(launchPoint) && e) {
        e.preventDefault()
        e.stopImmediatePropagation()
        return false
      }
    }
  } catch (e) {
    this.mylog.customOpenAppExecError(e)
  }
}}
```

列表型唤起点
![唤起配置化接口](./assets/resume/open-app-manager-ajax.png "唤起配置化接口")
![收集唤起点](./assets/resume/launchkey.png "收集唤起点")
![唤起动态参数](./assets/resume/dynamic.png "唤起动态参数")

### 唤起链路治理

#### 背景

点评增长部的核心指标是App的MAU和新激活量，因此目前点评一个重要的增长策略即为通过站外渠道（微信小程序、M站、百度小程序、头条小程序等）引导用户唤起/下载App。由于各个站外渠道依托的容器（游览器、微信、头条等）存在各种限制，以及App所处操作系统（Android、iOS）底层机制上的差异等问题，在唤起和引导下载方式上，我们设计了多种策略和方式，这要求前端、客户端、数据侧能够在其上达成统一的协议/约定，才能实现唤起跳转、渠道归因等功能。可以看出，整个唤起/下载链路是需要多方配合的，是复杂的，是不稳定的，其中某些环节（用户取消唤起，下载App）对于开发甚至是黑盒，在当前的条件下，想要提前发现问题，定位问题都是困难重重，往往需要耗费产品、前端、客户端、数据侧大量的时间，不仅效率低下，同时关乎用户是否能够进入App体验更好的服务。为此，我们建立了Sundae-唤起链路监控这个项目，希望通过埋点数据补齐，可视化，智能分析等方式让整个唤起/新激活链路变得“透明”，“可控”。

#### 目标

1. 提高排查唤起/新激活链路问题的效率
2. 提高唤起/新激活链路的稳定性
3. 各渠道唤起/新激活数据下降具备预警机制

#### 规划

STEP1:梳理唤起、下载关键路径，制定关键点监测内容
STEP2:各端埋点上报&异常监控，核心页面接入&数据验证
STEP3: 数据可视化&用户行为日志分析，数据波动告警&修复策略

#### 架构图

![架构图](./assets/resume/sundae.png "sundae架构图")

#### 行动

1. 唤起、下载关键链路上报梳理站外我们自己负责，站内推动客户端同学梳理
2. 调研探索站内外上报方案，日志相关使用logan、数据分析相关使用灵犀埋点
3. 如何将用户从站外到站内的各个链路关联？lch，六段式:scene:cid--bid:channel:customValue:traceid

唤起traceId（lxcuid-timestamp）：176faf46ff4c8-0b22e8def6ef05-326c7006-168000-176faf46ff4c8-1617884980660
口令traceId（lxcuid-timestamp-id）：176faf46ff4c8-0b22e8def6ef05-326c7006-168000-176faf46ff4c8-1617884980558-1A
其中，lxcuid 为cookie中_lxsdk_cuid字段的值（由灵犀sdk设置），timestamp为时间戳，id为2位16进制递增序列字符

#### 调研

#### 日志工具

结论：owl + LX + Raptor 结合使用
站外上报使用：owl, LX, Logan
站内上报使用：LX, Logan，Raptor不做要求

#### 链路id

作用：将用户的行为链路关联、上报数据的关联，只需第一个点上报即可

如何将用户行为链路关联？使用traceid
traceid需要考虑什么？id的唯一性
由谁去生成？前端 or 后端

![traceid生成方](./assets/resume/traceid.png "traceid生成方")

traceid方案比较

![traceid生成算法](./assets/resume/traceidGenerate.png "traceid生成算法")

指纹和自主生成的设计和验证成本较大，短期内我们先不考虑这两种方案（即使将来切换方案，成本并不高）。在小程序环境下，openId+时间戳是一个理想的方案，但lxcuid+时间戳也能满足我们对于traceId的要求，并且能够保持统一，因此我们选择利用lxcuid+时间戳的方式。

挑战1:traceid生成方案：由谁生成？如何生成？
挑战2:唤起、口令生成时机不同
挑战3:traceid精度问题

**结论**
首先，口令和唤起无论是单独使用还是叠加使用，都分别需要一个traceId
其次，在不同的终端上，这两个traceId的生成时机和格式有所不同：
小程序中，唤起和口令traceId相同（口令traceId复用唤起traceId），格式为lxcuid+时间戳
H5中，口令和唤起traceId不同，口令请求时生成口令traceId，点击唤起时生成唤起traceId，口令traceId格式为：lxcuid+时间戳+2位16进制自增数字，唤起traceId格式为：lxcuid+时间戳
唤起不太存在同市点击多次的情况、口令是批量生成的，所以为了唯一性，算法精度要求比较高

#### 数据如何验证

为什么需要校验？各个链路存在较多关联逻辑，数仓需要开发，开发即存在bug
校验方案：

1. demo校验，手动操作n次，数据库查询数据是否如预期
2. 相邻节点校验，即按照预期，各个链路间存在漏斗，看结果是否符合预期
3. universal link校验，ulink唤起失败 + ulink唤起成功 <= ulink唤起数

校验发现数仓历史代码有bug

#### 优化

唤起
| 角度             | 方案                       | 任务            |
|----------------|--------------------------|---------------|
| 特定容器环境唤起优化     | 针对低唤起率的机型或者容器进行修复和优化     | 微信            |
| 站内唤起scheme错误检查 | 针对0唤起率的机型或容器进行更多方案的探索    | 百度App(安卓)     |
| 唤起方式优化         | scheme错误导致唤起失败的进行反馈和告警修复 | UC浏览器（ios、安卓） |
| 引导唤起方式探索       | 安卓App Links技术探索          | 大象            |
| 提高唤起兼容性        | 针对不支持唤起的浏览器，出口令弹窗        | 美团App         |

微信治理：

1. 鉴权失败问题 -> 提升包引入时机
2. SPA应用 -> url改变后需重新鉴权
3. 微信聊天消息的情况下不能唤起（只支持卡片唤起） -> ulink

下载
安卓下载使用极简包
下载包进度检测？？未做

口令
复制口令成功率提升？ 未做
App核心页面支持解析？ 推动中

#### 数据

| 站外唤起SDK唤起方式 | 唤起方式占比 | 该方式唤起成功率 |
|-------------|--------|----------|
| intent      | 35.56% | 2.28%    |
| wxOpen      | 23.14% | 45.67%   |
| iframe      | 17.43% | 1.73%    |
| ulink       | 11.88% | 14.17%   |
| aOpen       | 11.56% | 0.11%    |
| href        | 0.72%  | 7.19%    |
| knbCore     | 0.06%  | 4.79%    |

#### 成果

1. 问题排查效率提升
2. 唤起到达率由 至 ，提升，尤其是微信环境，提升效果显著，
   原：唤起SDK启动率99%（过滤不合格url），唤起到达率13%-16%（用户未安装app,取消唤起、封禁等），站内落地页打开成功率95%（url问题）
      微信唤起到达率51%左右
   现： 73%，提升22pp，整体唤起率40%左右，提升25pp

    极简包引入：新激活量提升（212 - 123）/ 123 = 72.4%
3. 通过预警机制，预先发现问题并解决或回滚7例以上

### 唤起组件重构

#### 背景

唤起链路治理的一个手段：组件重构，自2020年初我们接手增长业务以来，增长业务类型越来越多样化，导致对唤起诉求也存在多样性，由于大部分唤起需求都比较紧急，在时间比较紧迫的情况下，我们设计出了满足不同唤起诉求的多个唤起组件，短时间内的开发导致这些组件往往缺乏良好的设计，此外，不同同学开发导致唤起组件代码风格迥异，包缺乏规范化，管理困难等问题。为了更好的服务好业务方以及方便组件的后续管理，我们决定对所有唤起组件进行一次梳理改造，在我们梳理唤起组件的过程中，我们发现多个唤起组件依赖的基础唤起组件存在以下问题：
组件升级成本高：唤起相关类组件繁多，目前一共有6个（@dp/open-app-gestalt：唤起基础组件、@dp/open-app-manager：唤起配置化组件、@dp/open-app-utils：唤起工具类组件、@dp/clip-dp-password：H5口令组件、@dp/launch-app-modal：Safari自动唤起UI组件、@dp/dp-password-popup-h5: h5口令弹窗组件）。唤起基础组件（@dp/open-app-gestalt）升级后，依赖唤起基础组件的多个包都需要相应升级，而这些组件维护在各个不同的项目中，往往需要手动依次升级，改动成本非常高；

包体积大：目前基础唤起组件压缩后的大小为56.1k（未压缩198.7k），体积较大，影响页面性能，导致唤起用户流失；
基础唤起组件扩展性差：为了兼容不同的浏览器，我们使用了if-else的方式调用对应的唤起方法；
灵活性差：不支持业务自定义逻辑；
由于大部分唤起组件都依赖唤起基础组件，所以我们需要优先对唤起基础组件进行重构。

#### 目标

1. 初始化plugins【defaultPlugins包括：url处理、唤起失败、口令生成，以及用户自定义plugins】&初始化唤起实例
2. 提供生命周期：beforeOpenApp、openAppFail[下载、下一页]

#### 行动

1. 编码语言ts+js共存，新组件使用ts
2. 包管理工具：monorepo+lerna
3. 唤起SDK重构【不同的系统支持不同的唤起方式，由原来的if-else通过策略模式改造】参考[唤端技术如何助力双11站外用户转化](https://mp.weixin.qq.com/s/Xe_FnJOu9I4DvU7rQ7xq5w)

降低包体积大小: 使用rollup打包、梳理业务逻辑，删除无关代码由原来的56.1k减少到20.9k，降低62.4%；
唤端行为引入插件模式以及生命周期，支持自定义，例如唤起失败、口令，扩展性强，灵活性高
换端方式采用策略模式，扩展性强

## UGC

### 时间节点

原生微信小程序编写写点评小程序 -> 产品提出需要开发一套H5版本的写点评，特点是几
先有的微信写点评小程序，后需要支持H5版本，主要支持微信、支付宝，功能大致一致，涉及技术选型，如何快速上线？8

### 你是如何技术选型的？

![多端框架技术选型](./assets/resume/dsl.png "多端框架技术选型")
各个维度对比下，维度包括DSL语言、多端支持什么端、组件库、上手成本等，最终选择了平台自研的框架，
这里需要知道cocktai的特点是什么？
cocktail跨端同构框架特点：
1.使用微信小程序为母本语言  -> 写点评已有微信小程序
2.轻量、易扩展，使用灵活 -> 写点评h5是个轻量业务
3.有稳定的团队维护 -> 框架使用过程问题需要咨询和解决
- DSL是微信小程序，转换理念是从

![业务特点](./assets/resume/thinking.png "多端框架技术选型")

富文本解析、表情包

### 写入侧遇到的挑战/难点是什么？又是如何解决的？

安全问题

### XSS攻击是什么？如何避免？

### CSRF攻击是什么？如何避免？

### 图片预览

参考(前端预览图片的两种方式)[https://juejin.cn/post/7355765560707399695?searchId=202409121757543878631BCE50151F4616]

### 内容相关的业务思考？

#### 写入侧

技术层面：安全问题
业务层面：

#### 展示侧

技术层面：如果有SEO的需求技术栈考虑SSR，无则对性能要求比较高的情况下建议SSR

服务库平台是用的什么？

#### contentservice负责什么

一部分产品经理的角色，一部分开发者的角色，除了cli工具这快其他部分都是我负责的：
1.组件梳理
2.组件库的脑爆、API评审会议、Code Review会议
3.开发规范的约定
4.测试框架的调研以及使用
5.官网维护

#### contentservice遇到的问题

1.如何确保代码风格，提供模版代码、提供工具包、文档规范、code review
2.服务出错是在contentservice下还是业务方自己应用，提供自定义设置方式
3.涉及到服务注册问题，组件聚合了多个服务，业务方如何知晓依赖哪些服务？ 脚本方式聚合依赖服务
4.执行测试用例时，会执行整个项目的测试用例，导致冲突较多 -> 只对变更的组件单独执行测试用例
5.jest测试如何保证快照不变 -> 对于一些数据库变化或者后端逻辑变化的返回，尽量mock

#### contentservice为什么使用jest

首先自动化测试框架我当时调研了3款产品，分别是Mocha、Jest以及Ava，其中Ava比较适合小型开源项目使用，Mocha是一块比较经典的测试框架，功能成熟，适合传统的Node项目或者Web项目使用，Jest是由Facebook编写的测试框架，适合使用Babel,ts,node,react,vue等框架的项目使用，支持快照测试。原生支持生成代码覆盖率，支持mock。

使用快照测试的优势：
1.开发者不用关注返回结果的细节；
2.开发者改动代码后，可以保证返回结果和原先结果完全一致。
缺点：
1.返回结果中如果有一小部分发生变化，测试就不能通过，不太适合有一部分动态数据的情况
2.第一次使用快照的时候需要生成一喜爱，当代码调整影响输出结果时，也需要重新生成快照

#### seeddesign项目学习

1. demo页支持react、vue查看，页面结构包括组件列表页、组件详情页，其中组件列表页包括顶部title+logo、原子层组件目录、分子层组件，组件详情页包括：组件名称+返回按钮、组件demo ui,技术栈包括react@16.8.1、react-router-dom@5.0.1、webpack@3.12.0，hashRouter，
目录包括：
webpack的配置包括：entry、output、module、pulgins、devServer、externals

2. 角色是什么？

3. 主要负责哪些工作？
   * 产品经理的角色
   * 组件的开发
   * 整包打包
   * 

4. 挑战是什么？

- 如何说服要做这个东西，怎么评估ROI，如何量化？
- 组件很多，靠自己写不现实，如何调动同事的积极性共建，加快项目完成，搞了多久？
  *组内认领，建议自己写过的+感兴趣的技术项目，绩效的一部份，api评审全组参与，增强参与感，有成长
  *组外，向上反馈，按组认领，及时push
  *组件加上归属人，增强开发者的荣誉感
  *待做：荣誉墙
- 如何推广？
  *把握机遇，赶上全公司推广星级组件改造，推动整个公司升级我们组件
  *部门前端群推广
  *公司集大前端推广
  
- 技术上的挑战
  1. svg的方案
- 组件技术方案评审：开发者完成技术文档，内容包括背景、目标、api定义、使用、技术方案，比较复杂的可以开会评审，简单的大家查看文档即可

@seed/react通过build-all-in-one导出思路：package下单独一个react包用于发布@seed/react,index.js用于export所有子包及变量定义， -> 根据文件夹名称获取package下面的所有子包名 -> 遍历各个子包，根据子包下的package.json文件里的main字段获取子包的入口 -> 读取入口文件里的代码，获取代码的export部分(包括组件名以及变量名) -> 更新@seed/react下package.json文件的依赖包及版本号 -> 根据项目的prettier格式将所有子包export出去

TODO
1.SVG如何转换成iconfont

## 盛哥问题

### 城市运营作业工具和后端系统的区别是什么？

服务群体不同，前者面向销售、外包以及商户，后者面向运营、产品团队

### 为什么要用微前端来解决聚合问题，不用行不行？微前端除了解决聚合问题，还能解决什么问题？

不行，首先解释一下这快项目中用到的一些微前端的技术，第一部分是一些效果数据的看板，看板是在公司的数据平台，对仅需支持数据查看比较简单的页面，我采用的是iframe的方案，其次，对于一些涉及到交互的页面，我采用的是qiankun的方案，为什么不得不用，先讲下微前端常用的一些解决方案以及缺点，iframe、路由分发

解决问题：
将巨石应用转变成碎石应用，无需维护庞大的项目
多个团队维护的问题
技术栈不一致的问题
增量迭代，项目技术栈比较陈旧，开发效率低，新需求迭代希望使用新技术，提高开发效率

### 谈谈优化用户体验做了哪些事情？

主要分为2部分，一是产品层面：当时拎包调研发现外包人员线下对商户铺码后，对于铺码是否有效、码是否产生评价数、以及后续的结账需要后台手动excel
二是技术层面：图片上传进行了压缩，加快了图片上传速度

## 代码评审是如何开展的，是在需求的哪个阶段进行的，成效如何？

首先我们在确定开发组件前，会先进行技术方案的评审，确保组件的入参定义以及组件的呈现无问题，另外也会确保组件的实现方案是正确的
那代码评审一般会在组件正式发布前，由组件开发者组内发起代码评审，代码评审是会议的形式。会议后根据意见修改后再code上发起code review，一般会有至少2位同学进行review，主要由高职级的同事、组件使用者等进行评审

效果比较好，通过code review目前没有业务方反馈有问题，另外，通过code review也确保了组件库的代码风格尽量保持一致

## 为什么要重构唤起组件，重构之后有哪些提升，谈谈对插件化的理解

一方面之前的唤起组件体积较大，我们希望可以优化唤起组件，减少体积，达到提高唤起率的目的
另一方面是唤起组件由于需要适配多种系统，代码中出现大量的面条代码，扩展性比较差

## 唤起看的核心指标有哪些，可以做功的指标有哪些？



## 唤起项目有哪些难点？

一是唤起配置化平台的搭建，如何设计组件，将唤起相关代码与业务代码进行解偶，如何解决不同技术栈接入的问题？

二是产品推动业务方使用，人家老的用的好好的，为什么要接你的东西？

三是涉及跨团队的合作，作为负责人，如何让对方配合你开发，把握开发进度，确保项目尽快完成

四是一些技术上的调研工作，例如别人家的唤起是怎么做的，有什么见解时

### 这个项目做了快2年多了，为什么需要那么久？

一方面人力不是全部focus在这一块，其次，这个是由技术主导的技术项目，从我们最初接手这块项目的时候是需要一定的时间去熟悉业务然后发现痛点，解决问题，像唤起配置化平台的搭建就是因为我们发现我们近1年内的人力耗费了很多时间在配合产品修改唤起策略，然后发起了唤起配置化平台的搭建，另外，平台搭建完后需要推动业务去使用，去收集平台使用反馈，再继续迭代更新，这也是比较耗费时间的。还有一方面是唤起链路数据可视化大盘的搭建是个跨部门多方合作的项目，需要迎合各个团队的时间，不停的去push，进展也会相对较慢。

### 写入评价有哪些难点和挑战？

一是技术选型上
二是传图适配上
三是写入侧需要考虑安全方面的问题

### 对写入的内容进行编码或转义应该是在前端做还是后端做，是在写入数据库前进行，还是读的时候进行？

xss
csrf
csp

### 谈谈组件库建设的思路

根据自身业务特点，抽离重复度较高的

原子层、分子层

#### 组件库建设前

拿seed design举例：这是个ui组件库
1.根据自身业务特点确定需要建设哪些组件，建设成什么样，例如ui组件库是否需要支持原子、分子
2.技术方案部分：
涉及部分调研工作，测试用例框架用什么？打包工具用什么？组件库提供方式是什么？组件库如何管理，是monprepo还是multirepo，即是维护在一个项目里还是拆分多个项目？开发语言确定，用ts还是js，支持react？vue？小程序？
那对于组件开发者而言工程能力相关的无需关心，可以抽离cli工具

提供demo页
提供组件库官网

组件库涉及共建，如何确保组件库开发风格一致？
1.cli工具支持模版代码
2.代码提交eslint，prettier，commitlint

组件库涉及共建，如何确保组件库高质量性？
1.技术方案评审
2.组件api评审
3.code review

组件库涉及共建，如何确保快速完成？
1.优先认领，可谁使用谁开发
2.作为kpi项目
3.向上反馈，得到ld支持，推动大家共建
4.建设荣誉墙，提升大家的荣誉感，也可建设激励制度

#### 组件库建设中

把握开发节奏，有风险及时暴露，及时push

#### 组件库建设后

官网维护
客服工作