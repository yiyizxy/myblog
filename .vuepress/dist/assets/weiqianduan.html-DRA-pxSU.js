import{_ as i,r as l,o as p,c as t,a,b as e,d as s,e as o}from"./app-COjMlnxi.js";const c="/myblog/assets/strictStyleIsolation-xpZZxEgd.png",r="/myblog/assets/experimentalStyleIsolation-Dy8qjWJT.png",u={},h=o(`<ul><li>qiankun</li><li>single-spa</li></ul><h2 id="qiankun-是什么-它解决了什么问题" tabindex="-1"><a class="header-anchor" href="#qiankun-是什么-它解决了什么问题"><span>qiankun 是什么，它解决了什么问题？</span></a></h2><p>qiankun是一个微前端框架，它允许开发者以微前端的方式构建大型应用，解决了传统单体应用难以维护和扩展的问题。</p><h2 id="在使用qiankun时-如何设计主应用和子应用" tabindex="-1"><a class="header-anchor" href="#在使用qiankun时-如何设计主应用和子应用"><span>在使用qiankun时，如何设计主应用和子应用？</span></a></h2><p>主应用是一个独立的应用，用于加载和管理子应用；子应用是可以独立部署和运行的应用片段。子应用通过暴露生命周期钩子与主应用进行交互。</p><h2 id="qiankun如何实现子应用之间的通信" tabindex="-1"><a class="header-anchor" href="#qiankun如何实现子应用之间的通信"><span>qiankun如何实现子应用之间的通信？??</span></a></h2><p>qiankun提供了全局状态管理和事件机制，允许子应用之间进行通信。通过qiankun传来expose和qiankun.useExposed可以实现子应用间的数据共享。</p><h2 id="如何保证qiankun中子应用的独立性" tabindex="-1"><a class="header-anchor" href="#如何保证qiankun中子应用的独立性"><span>如何保证qiankun中子应用的独立性？</span></a></h2><p>子应用应该有自己的状态管理，避免直接操作全局状态。使用qiankun提供的生命周期钩子进行状态隔离，确保子应用的独立性。</p><h2 id="qiankun支持哪些方式的子应用加载" tabindex="-1"><a class="header-anchor" href="#qiankun支持哪些方式的子应用加载"><span>qiankun支持哪些方式的子应用加载？</span></a></h2><p>qiankun支持动态加载和静态加载两种方式。动态加载允许按需加载子应用，而静态加载则是在主应用启动时就加载所有子应用。</p><h2 id="在使用qiankun构建微前端时-如何考虑性能优化" tabindex="-1"><a class="header-anchor" href="#在使用qiankun构建微前端时-如何考虑性能优化"><span>在使用qiankun构建微前端时，如何考虑性能优化？</span></a></h2><p>可以通过预加载子应用、懒加载资源、代码分割等技术进行性能优化。同时，利用qiankun的沙箱机制，减少不同子应用间的相互影响。</p><h2 id="微前端怎么调研的" tabindex="-1"><a class="header-anchor" href="#微前端怎么调研的"><span>微前端怎么调研的</span></a></h2><h3 id="微前端实现方案" tabindex="-1"><a class="header-anchor" href="#微前端实现方案"><span>微前端实现方案</span></a></h3><h4 id="iframe" tabindex="-1"><a class="header-anchor" href="#iframe"><span>iframe</span></a></h4><p>特点</p><ul><li><p>可以创建一个全新独立的宿主环境</p></li><li><p>浏览器支持很好</p></li><li><p>改造成本低</p></li></ul><p>不足</p><ul><li>dom割裂感严重，弹框只能在iframe，而且有滚动条</li><li>通讯非常麻烦，而且刷新iframe url状态丢失</li><li>前进后退按钮无效</li></ul><h3 id="路由分发" tabindex="-1"><a class="header-anchor" href="#路由分发"><span>路由分发</span></a></h3><p>路由分发式微前端，即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过HTTP服务器的反向代理来实现，又或者是应用框架自带的路由来解决。</p><p>就当前而言，通过路由分发式的微前端架构应该是采用最多、最易采用的 “微前端” 方案。但是这种方式看上去更像是多个前端应用的聚合，即我们只是将这些不同的前端应用拼凑到一起，使他们看起来像是一个完整的整体。但是它们并不是，每次用户从A应用到B应用的时候，往往需要刷新一下页面，这也是最大的缺点。</p><h4 id="qiankun" tabindex="-1"><a class="header-anchor" href="#qiankun"><span>qiankun</span></a></h4><p>基于single-spa的微前端方案</p><p>特点</p><ul><li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li><li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、- - experimentalStyleIsolation 两套适用不同场景的方案；</li><li>做了静态资源预加载能力；</li></ul><p>不足</p><ul><li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li><li>css沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li><li>无法同时激活多个子应用，也不支持子应用保活；</li><li>无法支持vite等esmodule脚本运行；</li></ul><p><code>window.__POWERED_BY_QIANKUN__</code>子应用判断是否qiankun,避免多次渲染 <code>__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</code>:主子应用本地调试时，存在资源路径引用的问题 <code>devServer -&gt; configg.headers -&gt; Access-control-allow-origin: *</code>: 子应用需要把跨域打开，上线时需要在niginix层配置</p><ol><li>父应用中注册应用，指定挂在的点</li><li>子应用中改写打包格式，只支持umd</li><li>子应用改写</li></ol><h3 id="微前端框架调研" tabindex="-1"><a class="header-anchor" href="#微前端框架调研"><span>微前端框架调研</span></a></h3><h4 id="singal-spa" tabindex="-1"><a class="header-anchor" href="#singal-spa"><span>singal-spa</span></a></h4><h4 id="qiankun【蚂蚁金服】" tabindex="-1"><a class="header-anchor" href="#qiankun【蚂蚁金服】"><span>qiankun【蚂蚁金服】</span></a></h4><p>优点：</p><ul><li>是蚂蚁金服推出的一款微前端框架，是singal-spa方案的增强版，在此基础上 提供了html entry以及sandbox等能力</li><li>生态比较完善、成熟度比较高、社区比较活跃，国内应用较多</li></ul><p>缺点：</p><ul><li>复杂度高，有一定的学习和配置成本</li><li>一定程度上 沙箱隔离机制会有一定的性能开销</li></ul><h4 id="micro-app【京东】" tabindex="-1"><a class="header-anchor" href="#micro-app【京东】"><span>Micro App【京东】</span></a></h4><p>优点</p><ul><li>轻量级：MicroApp 体积小，性能较好，适合对性能要求较高的项目。</li><li>简单易用：上手简单，API 设计清晰，开发成本低。</li><li>兼容性好：支持各种主流前端框架，并且能够与现有项目无缝集成。</li><li>灵活性强：提供灵活的加载和卸载机制，支持动态应用加载。</li></ul><p>缺点</p><ul><li>功能较少：相比Qiankun.js，MicroApp的功能相对较少，不支持某些高级特性。</li><li>社区资源较少：社区相对不够活跃，遇到问题时可能需要更多时间解决。</li></ul><p>字节：garfish</p><h4 id="wujie【腾讯】" tabindex="-1"><a class="header-anchor" href="#wujie【腾讯】"><span>Wujie【腾讯】</span></a></h4><p>优点</p><ul><li>高度隔离：Wujie 强调应用间的高度隔离，保证各个子应用之间不会互相影响。</li><li>高性能：针对性能进行了优化，适合对性能要求较高的项目。</li><li>现代化设计：采用现代化的设计思想，支持最新的前端技术和工具链。</li></ul><p>缺点</p><ul><li>相对较新：相较于 Qiankun.js 和 MicroApp，Wujie 较为新颖，社区和生态系统尚在发展中。</li><li>文档和支持：由于其新颖性，文档和支持可能不如 Qiankun.js 完善。</li></ul><p>Qiankun.js 适合大型项目和复杂场景，功能全面，但使用复杂度较高。 MicroApp 适合中小型项目，追求轻量级和高性能，功能相对较少。 Wujie 适合现代化前端项目，强调隔离和性能，但社区资源和支持尚待发展。</p><h2 id="微前端qiankun的实现原理" tabindex="-1"><a class="header-anchor" href="#微前端qiankun的实现原理"><span>微前端qiankun的实现原理</span></a></h2><p>qiankun是一个基于single-spa的微前端实现库，它能够帮助我们将多个独立的前端应用聚合成一个整体的应用。它的实现原理是通过监听路由变化，动态加载和卸载微应用，同时通过自定义事件系统来实现微应用之间的通信。</p><h2 id="遇到的问题" tabindex="-1"><a class="header-anchor" href="#遇到的问题"><span>遇到的问题</span></a></h2><p>1.微应用加载资源引入路径不对</p><pre><code class="language-js"><span class="token comment">// 设置public-path.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>__POWERED_BY_QIANKUN__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// @ts-ignore</span>
    __webpack_public_path__ <span class="token operator">=</span> window<span class="token punctuation">.</span>__INJECTED_PUBLIC_PATH_BY_QIANKUN__
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><p>2.本地调试跨域</p><pre><code class="language-js"><span class="token comment">// webpack配置</span>
<span class="token punctuation">{</span>
    <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token string-property property">&quot;Access-Control-Allow-Origin&quot;</span><span class="token operator">:</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><p>3.css隔离官方提供的两种方案【严格模式和实验模式】都会导致无法展示antd那种modal组件，如果不开启css隔离又回导致主子应用样式覆盖的问题，最终解决方案是</p><h2 id="qiankun的css隔离如何实现的" tabindex="-1"><a class="header-anchor" href="#qiankun的css隔离如何实现的"><span>qiankun的css隔离如何实现的</span></a></h2><h3 id="严格沙箱" tabindex="-1"><a class="header-anchor" href="#严格沙箱"><span>严格沙箱</span></a></h3><pre><code class="language-js"><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">sandbox</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 样式隔离特性</span>
        <span class="token literal-property property">strictStyleIsolation</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 严格沙箱</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>实现形式为将整个子应用放到Shadow DOM内进行嵌入，完全隔离了主子应用，shadow dom实际上是web components技术，就是一个attachshadow的api,然后用appendChild <img src="`+c+`" alt="strictStyleIsolation" title="strictStyleIsolation"> 缺点： 子应用的弹窗、抽屉、popover会挂在在body下，为了避免父元素的影响，例如<code>display: none</code>，会导致找不到样式文件 主应用不方便去修改子应用的样式</p><h3 id="实验性沙箱" tabindex="-1"><a class="header-anchor" href="#实验性沙箱"><span>实验性沙箱</span></a></h3><pre><code class="language-js"><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">sandbox</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 样式隔离特性</span>
        <span class="token literal-property property">experimentalStyleIsolation</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 实验性沙箱</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>实现形式类似于vue中style标签中的scoped属性，qiankun会自动为子应用所有的样式增加后缀标签，如：div[data-qiankun-microName] <img src="`+r+'" alt="experimentalStyleIsolation" title="experimentalStyleIsolation"> 缺点： 子应用的弹窗、抽屉、popover因插入到了主应用的body，所以导致样式丢失或应用了主应用了样式</p><p>既然可以自己做样式隔离，那为啥qiankuan还要提供，基于一些技术栈比较陈旧的项目，例如jquery，不支持css module的方式</p><h2 id="qiankun的js隔离如何实现的" tabindex="-1"><a class="header-anchor" href="#qiankun的js隔离如何实现的"><span>qiankun的js隔离如何实现的</span></a></h2><h2 id="怎么做的主应用或子应用单独启动" tabindex="-1"><a class="header-anchor" href="#怎么做的主应用或子应用单独启动"><span>怎么做的主应用或子应用单独启动</span></a></h2><h2 id="子应用单独启动情况下怎么获取主应用的cookie信息" tabindex="-1"><a class="header-anchor" href="#子应用单独启动情况下怎么获取主应用的cookie信息"><span>子应用单独启动情况下怎么获取主应用的cookie信息</span></a></h2><h2 id="proxysandbox和legacysandbox那个更好-为什么" tabindex="-1"><a class="header-anchor" href="#proxysandbox和legacysandbox那个更好-为什么"><span>proxySandbox和legacySandbox那个更好，为什么</span></a></h2><h2 id="legacysandbox会存在变量污染吗" tabindex="-1"><a class="header-anchor" href="#legacysandbox会存在变量污染吗"><span>legacySandbox会存在变量污染吗</span></a></h2><h2 id="legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现" tabindex="-1"><a class="header-anchor" href="#legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现"><span>legacysanbox是完全隔离吗，怎么实现完全隔离，在IE浏览器下怎么实现</span></a></h2><h2 id="proxysandbox和legacysandbox那个更好-为什么-1" tabindex="-1"><a class="header-anchor" href="#proxysandbox和legacysandbox那个更好-为什么-1"><span>proxySandbox和legacySandbox那个更好，为什么</span></a></h2><h2 id="legacysandbox会存在变量污染吗-1" tabindex="-1"><a class="header-anchor" href="#legacysandbox会存在变量污染吗-1"><span>legacySandbox会存在变量污染吗</span></a></h2><h2 id="legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现-1" tabindex="-1"><a class="header-anchor" href="#legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现-1"><span>legacysanbox是完全隔离吗，怎么实现完全隔离，在IE浏览器下怎么实现</span></a></h2><h2 id="webpack和vite的实现原理有何区别" tabindex="-1"><a class="header-anchor" href="#webpack和vite的实现原理有何区别"><span>webpack和vite的实现原理有何区别</span></a></h2><h2 id="wujie是什么-它有哪些核心特性" tabindex="-1"><a class="header-anchor" href="#wujie是什么-它有哪些核心特性"><span>wujie是什么，它有哪些核心特性？</span></a></h2><p>wujie是一个基于React的UI组件库，提供了一套丰富的组件用于构建用户界面，核心特性包括良好的用户体验、丰富的组件、灵活的主题定制等。</p><h2 id="在使用wujie时-如何保证组件的可访问性" tabindex="-1"><a class="header-anchor" href="#在使用wujie时-如何保证组件的可访问性"><span>在使用wujie时，如何保证组件的可访问性？</span></a></h2><p>通过遵循WAI-ARIA标准和提供必要的标签和属性来确保可访问性。同时，组件应易于使用键盘操作和屏幕阅读器。</p><h2 id="wujie中的组件如何支持响应式设计" tabindex="-1"><a class="header-anchor" href="#wujie中的组件如何支持响应式设计"><span>wujie中的组件如何支持响应式设计？</span></a></h2><p>wujie提供了响应式属性和样式，允许组件在不同尺寸的屏幕上正常显示。通过媒体查询和相对单位来实现响应式布局。</p><h2 id="wujie的组件是否支持自定义主题-如何实现" tabindex="-1"><a class="header-anchor" href="#wujie的组件是否支持自定义主题-如何实现"><span>wujie的组件是否支持自定义主题，如何实现？</span></a></h2><p>wujie允许通过修改样式变量或使用主题提供者来自定义主题。可以根据项目需求定制颜色、字体等。</p><h2 id="如何集成wujie组件到现有的react项目中" tabindex="-1"><a class="header-anchor" href="#如何集成wujie组件到现有的react项目中"><span>如何集成wujie组件到现有的React项目中？</span></a></h2><p>可以使用npm或yarn安装wujie包，然后导入所需的组件并使用。确保项目中使用的React版本与wujie兼容。</p><h2 id="在使用wujie组件时-如何进行性能优化" tabindex="-1"><a class="header-anchor" href="#在使用wujie组件时-如何进行性能优化"><span>在使用wujie组件时，如何进行性能优化？</span></a></h2><p>可以通过避免不必要的渲染、使用高效的选择器和优化组件结构来优化性能。利用组件的shouldComponentUpdate生命周期方法来减少渲染次数。</p><h2 id="wujie提供了哪些工具或服务来帮助开发者调试和测试组件" tabindex="-1"><a class="header-anchor" href="#wujie提供了哪些工具或服务来帮助开发者调试和测试组件"><span>wujie提供了哪些工具或服务来帮助开发者调试和测试组件？</span></a></h2><p>wujie可能提供了一些开发工具、文档和测试套件来帮助开发者。确保组件在不同环境下都能正常工作。</p><h2 id="wujie的组件库是否支持服务器端渲染-ssr-为什么" tabindex="-1"><a class="header-anchor" href="#wujie的组件库是否支持服务器端渲染-ssr-为什么"><span>wujie的组件库是否支持服务器端渲染（SSR），为什么？</span></a></h2><p>这取决于wujie的具体实现，如果组件能够兼容Node.js环境，那么理论上可以支持SSR，有助于提高首屏加载速度和SEO。</p><h2 id="如何为wujie-组件编写单元测试" tabindex="-1"><a class="header-anchor" href="#如何为wujie-组件编写单元测试"><span>如何为wujie 组件编写单元测试？</span></a></h2><p>使用如Jest、React Testing Library等测试框架，编写测试用例来验证组件的行为。确保组件在各种状态下都能正常工作。</p><h2 id="wujie中的组件是否遵循了哪些设计模式或最佳实践" tabindex="-1"><a class="header-anchor" href="#wujie中的组件是否遵循了哪些设计模式或最佳实践"><span>wujie中的组件是否遵循了哪些设计模式或最佳实践？</span></a></h2><p>可以询问组件库是否采用了如单向数据流、高阶组件等设计模式，以及是否遵循了React的最佳实践。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',97),d={href:"https://juejin.cn/post/7367674099877412891?searchId=202409012257009CFA4BE18AC675B9FA5C",target:"_blank",rel:"noopener noreferrer"},k={href:"https://juejin.cn/post/7212603829572911159?searchId=202409011729186123E565ABF9E29D14D2",target:"_blank",rel:"noopener noreferrer"},x={href:"https://juejin.cn/post/7339417495566696511?searchId=202409012257009CFA4BE18AC675B9FA5C",target:"_blank",rel:"noopener noreferrer"};function b(g,j){const n=l("ExternalLinkIcon");return p(),t("div",null,[h,a("p",null,[a("a",d,[e("Qiankun和Wujie前端面试频率较高的面试题和答案"),s(n)]),a("a",k,[e("微前端（无界）"),s(n)]),a("a",x,[e("qiankun微前端面试题"),s(n)])])])}const y=i(u,[["render",b],["__file","weiqianduan.html.vue"]]),q=JSON.parse('{"path":"/blogs/technology/kuangjia/weiqianduan.html","title":"微前端","lang":"en-US","frontmatter":{"title":"微前端","date":"2024/09/01","tags":["框架"],"categories":["框架"]},"headers":[{"level":2,"title":"qiankun 是什么，它解决了什么问题？","slug":"qiankun-是什么-它解决了什么问题","link":"#qiankun-是什么-它解决了什么问题","children":[]},{"level":2,"title":"在使用qiankun时，如何设计主应用和子应用？","slug":"在使用qiankun时-如何设计主应用和子应用","link":"#在使用qiankun时-如何设计主应用和子应用","children":[]},{"level":2,"title":"qiankun如何实现子应用之间的通信？??","slug":"qiankun如何实现子应用之间的通信","link":"#qiankun如何实现子应用之间的通信","children":[]},{"level":2,"title":"如何保证qiankun中子应用的独立性？","slug":"如何保证qiankun中子应用的独立性","link":"#如何保证qiankun中子应用的独立性","children":[]},{"level":2,"title":"qiankun支持哪些方式的子应用加载？","slug":"qiankun支持哪些方式的子应用加载","link":"#qiankun支持哪些方式的子应用加载","children":[]},{"level":2,"title":"在使用qiankun构建微前端时，如何考虑性能优化？","slug":"在使用qiankun构建微前端时-如何考虑性能优化","link":"#在使用qiankun构建微前端时-如何考虑性能优化","children":[]},{"level":2,"title":"微前端怎么调研的","slug":"微前端怎么调研的","link":"#微前端怎么调研的","children":[{"level":3,"title":"微前端实现方案","slug":"微前端实现方案","link":"#微前端实现方案","children":[]},{"level":3,"title":"路由分发","slug":"路由分发","link":"#路由分发","children":[]},{"level":3,"title":"微前端框架调研","slug":"微前端框架调研","link":"#微前端框架调研","children":[]}]},{"level":2,"title":"微前端qiankun的实现原理","slug":"微前端qiankun的实现原理","link":"#微前端qiankun的实现原理","children":[]},{"level":2,"title":"遇到的问题","slug":"遇到的问题","link":"#遇到的问题","children":[]},{"level":2,"title":"qiankun的css隔离如何实现的","slug":"qiankun的css隔离如何实现的","link":"#qiankun的css隔离如何实现的","children":[{"level":3,"title":"严格沙箱","slug":"严格沙箱","link":"#严格沙箱","children":[]},{"level":3,"title":"实验性沙箱","slug":"实验性沙箱","link":"#实验性沙箱","children":[]}]},{"level":2,"title":"qiankun的js隔离如何实现的","slug":"qiankun的js隔离如何实现的","link":"#qiankun的js隔离如何实现的","children":[]},{"level":2,"title":"怎么做的主应用或子应用单独启动","slug":"怎么做的主应用或子应用单独启动","link":"#怎么做的主应用或子应用单独启动","children":[]},{"level":2,"title":"子应用单独启动情况下怎么获取主应用的cookie信息","slug":"子应用单独启动情况下怎么获取主应用的cookie信息","link":"#子应用单独启动情况下怎么获取主应用的cookie信息","children":[]},{"level":2,"title":"proxySandbox和legacySandbox那个更好，为什么","slug":"proxysandbox和legacysandbox那个更好-为什么","link":"#proxysandbox和legacysandbox那个更好-为什么","children":[]},{"level":2,"title":"legacySandbox会存在变量污染吗","slug":"legacysandbox会存在变量污染吗","link":"#legacysandbox会存在变量污染吗","children":[]},{"level":2,"title":"legacysanbox是完全隔离吗，怎么实现完全隔离，在IE浏览器下怎么实现","slug":"legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现","link":"#legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现","children":[]},{"level":2,"title":"proxySandbox和legacySandbox那个更好，为什么","slug":"proxysandbox和legacysandbox那个更好-为什么-1","link":"#proxysandbox和legacysandbox那个更好-为什么-1","children":[]},{"level":2,"title":"legacySandbox会存在变量污染吗","slug":"legacysandbox会存在变量污染吗-1","link":"#legacysandbox会存在变量污染吗-1","children":[]},{"level":2,"title":"legacysanbox是完全隔离吗，怎么实现完全隔离，在IE浏览器下怎么实现","slug":"legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现-1","link":"#legacysanbox是完全隔离吗-怎么实现完全隔离-在ie浏览器下怎么实现-1","children":[]},{"level":2,"title":"webpack和vite的实现原理有何区别","slug":"webpack和vite的实现原理有何区别","link":"#webpack和vite的实现原理有何区别","children":[]},{"level":2,"title":"wujie是什么，它有哪些核心特性？","slug":"wujie是什么-它有哪些核心特性","link":"#wujie是什么-它有哪些核心特性","children":[]},{"level":2,"title":"在使用wujie时，如何保证组件的可访问性？","slug":"在使用wujie时-如何保证组件的可访问性","link":"#在使用wujie时-如何保证组件的可访问性","children":[]},{"level":2,"title":"wujie中的组件如何支持响应式设计？","slug":"wujie中的组件如何支持响应式设计","link":"#wujie中的组件如何支持响应式设计","children":[]},{"level":2,"title":"wujie的组件是否支持自定义主题，如何实现？","slug":"wujie的组件是否支持自定义主题-如何实现","link":"#wujie的组件是否支持自定义主题-如何实现","children":[]},{"level":2,"title":"如何集成wujie组件到现有的React项目中？","slug":"如何集成wujie组件到现有的react项目中","link":"#如何集成wujie组件到现有的react项目中","children":[]},{"level":2,"title":"在使用wujie组件时，如何进行性能优化？","slug":"在使用wujie组件时-如何进行性能优化","link":"#在使用wujie组件时-如何进行性能优化","children":[]},{"level":2,"title":"wujie提供了哪些工具或服务来帮助开发者调试和测试组件？","slug":"wujie提供了哪些工具或服务来帮助开发者调试和测试组件","link":"#wujie提供了哪些工具或服务来帮助开发者调试和测试组件","children":[]},{"level":2,"title":"wujie的组件库是否支持服务器端渲染（SSR），为什么？","slug":"wujie的组件库是否支持服务器端渲染-ssr-为什么","link":"#wujie的组件库是否支持服务器端渲染-ssr-为什么","children":[]},{"level":2,"title":"如何为wujie 组件编写单元测试？","slug":"如何为wujie-组件编写单元测试","link":"#如何为wujie-组件编写单元测试","children":[]},{"level":2,"title":"wujie中的组件是否遵循了哪些设计模式或最佳实践？","slug":"wujie中的组件是否遵循了哪些设计模式或最佳实践","link":"#wujie中的组件是否遵循了哪些设计模式或最佳实践","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1719836602000,"updatedTime":1725723914000,"contributors":[{"name":"zhuxiaoying","email":"zhuxiaoying@meituan.com","commits":7}]},"filePathRelative":"blogs/technology/框架/微前端.md"}');export{y as comp,q as data};
