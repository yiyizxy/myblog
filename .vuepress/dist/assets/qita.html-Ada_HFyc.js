import{_ as e,o as i,c as l,e as a}from"./app-COjMlnxi.js";const n="/myblog/assets/osi-C2Bhv-vN.png",s={},t=a('<h2 id="从输入url到页面展示这中间发生了什么" tabindex="-1"><a class="header-anchor" href="#从输入url到页面展示这中间发生了什么"><span>从输入URL到页面展示这中间发生了什么</span></a></h2><ol><li>浏览器进程通过进程间通信（IPC）把URL请求发送给网络进程。</li><li>【URL解析】网络进程接收到URL请求后会先判断输入的是否是合法url还是搜索词，如果是url，检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程。</li><li>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下： *【DNS解析】进行DNS解析，获取服务器IP地址，端口（非dns解析，根据协议指定）。 *【TCP连接】利用IP地址和服务器建立TCP连接。 *【HTTP请求】构建HTTP请求</li><li>【响应请求】网络进程解析响应流程： *检查状态码，如果是301（永久重定向）/302（临时重定向），则需要重定向，从Location字段中读取地址，重新进行第4步，如果是200，则继续处理请求。 *200响应处理：检查响应类型 Content-Type，如果是字节流类型，则将请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</li><li>【页面渲染】 *解析HTML，构建DOM树 *解析CSS，生成CSS规则树 *合并DOM树和CSS规则树，生成render树 *布局render树（reflow），负责各元素尺寸、位置的计算 *绘制render树(paint)，绘制页面的像素信息 *浏览器会将各层的信息发送给GPU，GPU会将各层合成，显示在屏幕上</li></ol><h2 id="chrome打开网页会启动哪些进程" tabindex="-1"><a class="header-anchor" href="#chrome打开网页会启动哪些进程"><span>Chrome打开网页会启动哪些进程</span></a></h2><p>最新版Chrome打开网页涉及到打开一个浏览器的主进程、一个GPU进程、一个网络进程、多个渲染进程以及多个插件进程，其中浏览器的主进程主要负责界面的显示、用户的交互以及子进程的管理，同时提供一些存储能力，渲染进程主要是把HTML、CSS和JS转换为用户可交互的网页，排版引擎BLink和JS引擎V8都是运行在这个进程中的，处于安全考虑，chrome进程会给每个tab分配一个渲染进程，👎大部分运行在沙箱模式下，js进程、渲染进程、</p><h2 id="网络分层模型" tabindex="-1"><a class="header-anchor" href="#网络分层模型"><span>网络分层模型</span></a></h2><h3 id="osi的7层模型" tabindex="-1"><a class="header-anchor" href="#osi的7层模型"><span>OSI的7层模型</span></a></h3><p><img src="'+n+`" alt="OSI" title="OSI"></p><p>应用层：定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如DNS、HTTP、SMTP(简单邮件传输协议)等【可以理解为：规定数据的传输协议。】 表示层：表示层供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息可以被另一个系统应用层识别。【可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信。】 会话层：建立、管理和终止表示层与实体之间的通信会话。【建立一个连接（自动的手机信息、自动的网络寻址）。】 传输层：向高层提供可靠的端到端的网络数据流服务。【可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议。】 网络层：网络层负责在源和终点之间建立连接。【可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！】 数据链路层：通过物理网络链路提供数据传输。不同的数据链路层定义了不同的网络和协议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流。 【可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式。】 物理层：物理层负责最后将信息编码成电流脉冲或其它信号（例如电缆、光纤、网卡、集线器等等）用于网上传输。【RJ45等将数据转化成0和1】</p><h3 id="tcp-ip网络分层模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip网络分层模型"><span>TCP/IP网络分层模型</span></a></h3><p>应用层【会话、表示、应用】：对应于OSI七层参考模型的应用层和表达层会话层。 传输层：提供两种端到端的通信服务。其中TCP协议提供可靠的数据流运输服务,UDP协议提供不可靠的用户数据报服务。 网络层：本层包含IP协议、RIP协议,负责数据的包装、寻址和路由。同时还包含网间控制报文协议用来提供网络诊断信息。【可以理解为：该层能确定计算机的位置】 网络接口层【物理、数据链路层】：网络接口层包括用于协作IP数据在已有网络介质上传输的协议。它定义像地址解析协议这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。【可以理解为：确定网络数据包的形式】</p><h2 id="http1-0与2-0区别" tabindex="-1"><a class="header-anchor" href="#http1-0与2-0区别"><span>HTTP1.0与2.0区别</span></a></h2><h2 id="udp-tcp是网络七层协议中哪一层的协议-区别是什么-分别适用于什么场景" tabindex="-1"><a class="header-anchor" href="#udp-tcp是网络七层协议中哪一层的协议-区别是什么-分别适用于什么场景"><span>UDP,TCP是网络七层协议中哪一层的协议,区别是什么,分别适用于什么场景?</span></a></h2><p>传输层。 在TCP/IP模型中,传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。</p><ul><li>TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。需要三次握手建立连接,才能进行数据传输。在发送端,它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端,它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制,以避免缓慢接收的接收方没有足够的缓冲区接收发 送方发送的大量数据。</li><li>UDP协议是一个无连接、不可靠的协议,不与对方建立连接,而是直接就把数据包发送过去。主要适用于不需要对报文进行排序和流量控制的场合。UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如,我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常, 其实“ping”命令的原理就是向对方主机发送UDP数据包,然后对方主机确认收到数据包,如果数据包是否到达的消息及时反馈回来,那么网络就是通的。</li></ul><h2 id="tcp对应的协议和udp对应的协议" tabindex="-1"><a class="header-anchor" href="#tcp对应的协议和udp对应的协议"><span>TCP对应的协议和UDP对应的协议</span></a></h2><h3 id="tcp对应的协议" tabindex="-1"><a class="header-anchor" href="#tcp对应的协议"><span>TCP对应的协议</span></a></h3><ul><li>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li><li>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li><li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li><li>HTTP协议：是从Web服务器传输超文本到本地浏览器的传送协议。</li></ul><h3 id="udp对应的协议" tabindex="-1"><a class="header-anchor" href="#udp对应的协议"><span>UDP对应的协议</span></a></h3><ul><li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li><li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li><li>TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li></ul><h2 id="tcp三次握手-能不能改成两次" tabindex="-1"><a class="header-anchor" href="#tcp三次握手-能不能改成两次"><span>TCP三次握手？能不能改成两次？</span></a></h2><p>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p><ul><li>TCP的三次握手过程：主机 A 向 B 发送连接请求；主机 B 对收到的主机 A 的报文段进行确认；主机 A 再次对主机 B 的确认进行确认。</li><li>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B ，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。</li><li>采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</li></ul><h2 id="tcp的可靠性如何保证" tabindex="-1"><a class="header-anchor" href="#tcp的可靠性如何保证"><span>TCP的可靠性如何保证？</span></a></h2><p>在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。</p><h2 id="ping命令使用的是什么协议" tabindex="-1"><a class="header-anchor" href="#ping命令使用的是什么协议"><span>ping命令使用的是什么协议</span></a></h2><p>ICMP</p><h2 id="arp协议的工作原理" tabindex="-1"><a class="header-anchor" href="#arp协议的工作原理"><span>ARP协议的工作原理</span></a></h2><p>首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><h2 id="cookie和session的区别" tabindex="-1"><a class="header-anchor" href="#cookie和session的区别"><span>cookie和session的区别</span></a></h2><p>cookie和session是Web开发中常用的两种技术，用于在客户端和服务器之间保存用户状态信息。虽然它们都可以用于用户身份验证、会话管理等功能，但它们在工作原理、存储位置、安全性等方面有显著的区别。</p><h3 id="存储位置" tabindex="-1"><a class="header-anchor" href="#存储位置"><span>存储位置</span></a></h3><ul><li>Cookie是存储在客户端（浏览器）的一小段数据。</li><li>Session数据存储在服务器端。</li></ul><h3 id="存储容量" tabindex="-1"><a class="header-anchor" href="#存储容量"><span>存储容量</span></a></h3><p>cookie:每个cookie的大小通常限制在4KB以内。每个域名下的Cookie总数也有一定限制（通常是 20 个左右）。</p><p>session:较大容量,数据存储在服务器上，理论上可以存储更大量的数据，只受限于服务器的存储能力。</p><h3 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性"><span>安全性</span></a></h3><p>cookie:存储在客户端，容易被用户篡改，安全性较低:需要通过HTTPS和HttpOnly、Secure 等属性来增加安全性。 session:数据存储在服务器端，用户无法直接访问和修改，安全性较高</p><h3 id="持久性" tabindex="-1"><a class="header-anchor" href="#持久性"><span>持久性</span></a></h3><p>cookie:可以设置过期时间，决定其是持久的还是会话级的。持久Cookie存储在客户端硬盘上，会话 Cookie 存储在内存中，浏览器关闭后会被删除。 Session:session通常与用户会话相关联，浏览器关闭后，Session会失效。服务器可以设置 Session 的过期时间。</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><p>cookie:适合存储小量数据,如用户偏好设置、登录状态等。可以跨页面、跨会话使用。 Session:适合存储敏感数据和大量数据:如用户身份信息、购物车数据等。适用于需要高安全性和较大数据存储的场景。</p><h2 id="cookie构成" tabindex="-1"><a class="header-anchor" href="#cookie构成"><span>cookie构成</span></a></h2><pre><code class="language-js">document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">&quot;username=JohnDoe; expires=Fri, 31 Dec 2024 23:59:59 GMT; path=/; domain=example.com; secure; HttpOnly; SameSite=Lax&quot;</span><span class="token punctuation">;</span>
</code></pre><ol><li>cookie的名称</li><li>过期时间：expires</li><li>path:/: 限制访问的路径，对整个站点有效</li><li>domain=example.com: Cookie对example.com域名有效</li><li>secure：Cookie只会通过HTTPS连接发送。</li><li>HttpOnly：Cookie不能通过JavaScript访问。防止XSS攻击</li><li>SameSite=Lax：允许部分第三方请求携带Cookie。</li></ol><p>Site 属性可以帮助防止跨站请求伪造攻击（CSRF）。它有三个值：</p><ol><li>Strict：完全禁止第三方请求携带Cookie。</li><li>Lax：允许部分第三方请求携带Cookie，例如从外部站点导航到目标站点的GET请求。</li><li>None：允许所有第三方请求携带Cookie，但必须设置Secure标志。</li></ol>`,46),o=[t];function p(c,h){return i(),l("div",null,o)}const d=e(s,[["render",p],["__file","qita.html.vue"]]),P=JSON.parse('{"path":"/blogs/technology/network/qita.html","title":"其他","lang":"en-US","frontmatter":{"title":"其他","date":"2024/07/26","tags":["网络"],"categories":["网络"]},"headers":[{"level":2,"title":"从输入URL到页面展示这中间发生了什么","slug":"从输入url到页面展示这中间发生了什么","link":"#从输入url到页面展示这中间发生了什么","children":[]},{"level":2,"title":"Chrome打开网页会启动哪些进程","slug":"chrome打开网页会启动哪些进程","link":"#chrome打开网页会启动哪些进程","children":[]},{"level":2,"title":"网络分层模型","slug":"网络分层模型","link":"#网络分层模型","children":[{"level":3,"title":"OSI的7层模型","slug":"osi的7层模型","link":"#osi的7层模型","children":[]},{"level":3,"title":"TCP/IP网络分层模型","slug":"tcp-ip网络分层模型","link":"#tcp-ip网络分层模型","children":[]}]},{"level":2,"title":"HTTP1.0与2.0区别","slug":"http1-0与2-0区别","link":"#http1-0与2-0区别","children":[]},{"level":2,"title":"UDP,TCP是网络七层协议中哪一层的协议,区别是什么,分别适用于什么场景?","slug":"udp-tcp是网络七层协议中哪一层的协议-区别是什么-分别适用于什么场景","link":"#udp-tcp是网络七层协议中哪一层的协议-区别是什么-分别适用于什么场景","children":[]},{"level":2,"title":"TCP对应的协议和UDP对应的协议","slug":"tcp对应的协议和udp对应的协议","link":"#tcp对应的协议和udp对应的协议","children":[{"level":3,"title":"TCP对应的协议","slug":"tcp对应的协议","link":"#tcp对应的协议","children":[]},{"level":3,"title":"UDP对应的协议","slug":"udp对应的协议","link":"#udp对应的协议","children":[]}]},{"level":2,"title":"TCP三次握手？能不能改成两次？","slug":"tcp三次握手-能不能改成两次","link":"#tcp三次握手-能不能改成两次","children":[]},{"level":2,"title":"TCP的可靠性如何保证？","slug":"tcp的可靠性如何保证","link":"#tcp的可靠性如何保证","children":[]},{"level":2,"title":"ping命令使用的是什么协议","slug":"ping命令使用的是什么协议","link":"#ping命令使用的是什么协议","children":[]},{"level":2,"title":"ARP协议的工作原理","slug":"arp协议的工作原理","link":"#arp协议的工作原理","children":[]},{"level":2,"title":"cookie和session的区别","slug":"cookie和session的区别","link":"#cookie和session的区别","children":[{"level":3,"title":"存储位置","slug":"存储位置","link":"#存储位置","children":[]},{"level":3,"title":"存储容量","slug":"存储容量","link":"#存储容量","children":[]},{"level":3,"title":"安全性","slug":"安全性","link":"#安全性","children":[]},{"level":3,"title":"持久性","slug":"持久性","link":"#持久性","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"cookie构成","slug":"cookie构成","link":"#cookie构成","children":[]}],"git":{"createdTime":1721991355000,"updatedTime":1725440342000,"contributors":[{"name":"zhuxiaoying","email":"zhuxiaoying@meituan.com","commits":5}]},"filePathRelative":"blogs/technology/network/其他.md"}');export{d as comp,P as data};
