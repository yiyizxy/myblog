import{_ as t,r as o,o as e,c,a as n,b as s,d as p,e as l}from"./app-COjMlnxi.js";const u="/myblog/assets/mark-DbA0Ui50.png",i={},k=l(`<h2 id="内存溢出-vs-内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存溢出-vs-内存泄漏"><span>内存溢出 vs 内存泄漏</span></a></h2><h3 id="内存溢出-out-of-memory-oom" tabindex="-1"><a class="header-anchor" href="#内存溢出-out-of-memory-oom"><span>内存溢出（out of memory OOM）</span></a></h3><p>一种程序运行出现的错误。当程序运行时需要的内存超过剩余的内存时，就会内存溢出的错误。</p><pre><code class="language-js"><span class="token comment">// 由于循环量过大导致物理内存不够</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">100000000</span><span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;-----------------&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="内存泄漏-memory-leak" tabindex="-1"><a class="header-anchor" href="#内存泄漏-memory-leak"><span>内存泄漏（memory leak）</span></a></h3><ul><li>占用的内存没有及时释放。</li><li>内存泄露积累多了就容易导致内存溢出。</li></ul><h3 id="常见内存泄漏" tabindex="-1"><a class="header-anchor" href="#常见内存泄漏"><span>常见内存泄漏</span></a></h3><ul><li>全局变量意外赋值</li><li>闭包导致变量无法释放</li><li>没有及时清理的定时器</li><li>事件监听没有及时清除</li><li>数据结构（如数组、Map、Set）持续增长</li><li>其他</li></ul><pre><code class="language-js"><span class="token comment">// 全局变量意外赋值</span>
<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 闭包导致变量无法释放</span>
<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> fn2
<span class="token punctuation">}</span>
<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 执行完函数之后a没有被释放掉，是因为fn保存了fn1函数。</span>
<span class="token comment">// fn = null // 释放内存</span>

<span class="token comment">// 没有及时清理的定时器或回调函数</span>
<span class="token keyword">var</span> someResource <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理 node 和 someResource</span>
        node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>someResource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 其他</span>
<span class="token comment">// console.log(data)</span>
<span class="token comment">// 事件监听</span>
<span class="token comment">// 循环引用</span>
</code></pre><h2 id="垃圾回收常见算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收常见算法"><span>垃圾回收常见算法</span></a></h2><h3 id="标记清除法" tabindex="-1"><a class="header-anchor" href="#标记清除法"><span>标记清除法</span></a></h3><p>整个标记清除算法大致过程就像下面这样:</p><ol><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li><li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li></ol><p>优点 标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</p><p>缺点 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</p><p><img src="`+u+`" alt="标记清除法" title="标记清除法"></p><h3 id="引用计数算法" tabindex="-1"><a class="header-anchor" href="#引用计数算法"><span>引用计数算法</span></a></h3><ol><li>它的策略是跟踪记录每个变量值被使用的次数，当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为1，</li><li>如果同一个值又被赋给另一个变量，那么引用数加 1</li><li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li><li>当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为0的值占用的内存</li></ol><p>优点 只要引用次数为0时，就会被立即回收</p><p>缺点 需要维护一个计数器，占用很大的位置，而且不知道被引用次数的上限，导致遇到循环引用的情况下无法回收</p><h2 id="v8垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#v8垃圾回收机制"><span>V8垃圾回收机制</span></a></h2><ul><li>V8垃圾回收策略主要基于分代式垃圾回收机制，将堆中内存分为新生代区和老生代区，采用不同的垃圾回收机制。</li><li>新生代的对象主要为存活时间较短的对象，即新产生的对象，通常只有1-8M容量，老生代主要存放存活时间较长或者常驻内存的对象，即经历过新生代垃圾回收还存活下来的对象，容量通常比较大。</li><li>新生代垃圾回收使用Scavenge算法，将堆内存一分为二，分别为使用区和空间区，新加入的对象会把被放入使用区，如果使用区内存满后会执行垃圾回收，首先，新生代垃圾回收器会对使用区的中的活动对象标记，标记完成后会将使用区的活动对象复制到空闲区，随后进入垃圾回收，即将非活动对象占用的空间清理掉，最后进行角色替换，将原使用区变成空闲区，将空闲区转变为使用区。</li><li>当一个对象经过多次复制后依然存活，则被认为是生命周期较长的对象，会被晋升到老生代区，另外，如果某个对象复制到空闲区时，占使用区25%的内存以上也会直接晋升到老生代区</li><li>老生代垃圾回收则采用标记清除法，首先是标记阶段，对老生代第一次遍历，标记存活对象；然后对老生代第二次遍历，清除非活动对象；接着采用标记整理法将存活对象往内存的一端移动，最后清理存活对象外的内存。</li></ul><p>新生代垃圾回收使用Scavenge算法缺点是啥？只能使用堆内存的一半，但是由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上比较优秀。</p><h2 id="内存泄漏排查思路" tabindex="-1"><a class="header-anchor" href="#内存泄漏排查思路"><span>内存泄漏排查思路</span></a></h2><ul><li>对于缓慢上涨最终OOM这种类型的内存泄漏，我们有充足的时间去抓Heapsnapshot，进而分析堆快照来定位泄漏点。【Heapsnapshot】</li><li></li></ul><h3 id="heapsnapshot" tabindex="-1"><a class="header-anchor" href="#heapsnapshot"><span>Heapsnapshot</span></a></h3><p>参考seo图文页</p><p>想要分析定位内存泄漏问题，首先我们要去获取 Node.js 进程在发生泄漏时的堆上各个对象和它们间的引用关系，这个保存了堆上各个对象以及其引用关系的文件就是堆快照。V8 引擎提供了一个接口可以让我们很方便地实时获取到堆快照，下面我们介绍两种不同的方法来获取。</p><pre><code class="language-js"><span class="token keyword">const</span> heapdump <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;heapdump&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 可以用setInterval，每隔一段时间生成堆快照</span>
<span class="token keyword">const</span> heapdump <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;heapdump&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;path&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> filename <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;.heapsnapshot&#39;</span><span class="token punctuation">;</span>
  heapdump<span class="token punctuation">.</span><span class="token function">writeSnapshot</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 手动触发heapdump接口生成堆快照</span>
heapdump<span class="token punctuation">.</span><span class="token function">writeSnapshot</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span>  Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;.heapsnapshot&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Chrome DevTools 我们使用 Chrome DevTools 来分析前面生成的 heapsnapshot 文件。调出 Chrome DevTools -&gt; Memory -&gt; Load，按顺序依次加载前面生成的3个heapsnapshot文件。单击第 3个堆快照，在左上角有个下拉菜单，有如下 4 个选项：</p><p>Summary：以构造函数名分类显示。</p><p>Comparison：比较多个快照之间的差异。</p><p>Containment：查看整个GC（garbage collection）路径。</p><p>Statistics：以饼状图显示内存占用信息。 通常我们只会用前两个选项；第 3 个选项一般用不到，因为在展开 Summary 和 Comparison 中的每一项时，都可以看到从GC roots到这个对象的路径；</p><p>切换到Statistics页，如下所示：</p>`,35),r={href:"https://www.npmjs.com/package/heapdump",target:"_blank",rel:"noopener noreferrer"},h=n("li",null,"利用chrome DevTools分析heapsnapshot文件，调出 Chrome DevTools -> Memory -> Load",-1),m={href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"};function d(f,g){const a=o("ExternalLinkIcon");return e(),c("div",null,[k,n("ul",null,[n("li",null,[s("接入"),n("a",r,[s("heapdump"),p(a)]),s("包，利用压测工具，生成内存快照。")]),h]),n("p",null,[n("a",m,[s("你真的了解垃圾回收机制吗"),p(a)])])])}const v=t(i,[["render",d],["__file","lajihuishou.html.vue"]]),_=JSON.parse('{"path":"/blogs/technology/node/lajihuishou.html","title":"垃圾回收","lang":"en-US","frontmatter":{"title":"垃圾回收","date":"2024/07/28","tags":["javascript"],"categories":["javascript"]},"headers":[{"level":2,"title":"内存溢出 vs 内存泄漏","slug":"内存溢出-vs-内存泄漏","link":"#内存溢出-vs-内存泄漏","children":[{"level":3,"title":"内存溢出（out of memory OOM）","slug":"内存溢出-out-of-memory-oom","link":"#内存溢出-out-of-memory-oom","children":[]},{"level":3,"title":"内存泄漏（memory leak）","slug":"内存泄漏-memory-leak","link":"#内存泄漏-memory-leak","children":[]},{"level":3,"title":"常见内存泄漏","slug":"常见内存泄漏","link":"#常见内存泄漏","children":[]}]},{"level":2,"title":"垃圾回收常见算法","slug":"垃圾回收常见算法","link":"#垃圾回收常见算法","children":[{"level":3,"title":"标记清除法","slug":"标记清除法","link":"#标记清除法","children":[]},{"level":3,"title":"引用计数算法","slug":"引用计数算法","link":"#引用计数算法","children":[]}]},{"level":2,"title":"V8垃圾回收机制","slug":"v8垃圾回收机制","link":"#v8垃圾回收机制","children":[]},{"level":2,"title":"内存泄漏排查思路","slug":"内存泄漏排查思路","link":"#内存泄漏排查思路","children":[{"level":3,"title":"Heapsnapshot","slug":"heapsnapshot","link":"#heapsnapshot","children":[]}]}],"git":{"createdTime":1722145683000,"updatedTime":1725607239000,"contributors":[{"name":"zhuxiaoying","email":"zhuxiaoying@meituan.com","commits":3}]},"filePathRelative":"blogs/technology/node/垃圾回收.md"}');export{v as comp,_ as data};
